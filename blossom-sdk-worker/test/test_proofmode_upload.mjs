#!/usr/bin/env node
// ABOUTME: Test upload with ProofMode headers to verify validation works
// ABOUTME: Creates mock ProofMode manifest, signature, and attestation

import { webcrypto } from 'crypto';
import { readFileSync } from 'fs';

if (!globalThis.crypto) {
  globalThis.crypto = webcrypto;
}

const UPLOAD_URL = 'https://blossom.divine.video/upload';

function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

async function sha256(data) {
  const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;
  const hash = await crypto.subtle.digest('SHA-256', buffer);
  return bytesToHex(new Uint8Array(hash));
}

async function generateKeypair() {
  const privkey = bytesToHex(crypto.getRandomValues(new Uint8Array(32)));
  const pubkey = await sha256(hexToBytes(privkey));
  return { privkey, pubkey };
}

async function createAuthEvent(pubkey, privkey, sha256Hash, expiration) {
  const event = {
    kind: 24242,
    created_at: Math.floor(Date.now() / 1000),
    tags: [
      ['t', 'upload'],
      ['x', sha256Hash],
      ['expiration', expiration.toString()]
    ],
    content: 'Upload to Blossom with ProofMode',
    pubkey
  };

  const serialized = JSON.stringify([
    0,
    event.pubkey,
    event.created_at,
    event.kind,
    event.tags,
    event.content
  ]);

  event.id = await sha256(serialized);
  event.sig = '0'.repeat(128); // Dummy sig for dev mode

  return event;
}

/**
 * Create mock ProofMode manifest
 */
function createProofModeManifest(videoSha256) {
  const sessionId = crypto.randomUUID();
  const timestamp = new Date().toISOString();

  return {
    version: "2.0",
    sessionId,
    timestamp,
    videoHash: videoSha256,
    frameHashes: [
      sha256("frame1"),
      sha256("frame2"),
      sha256("frame3")
    ],
    device: {
      manufacturer: "Test Device",
      model: "Mock Model",
      osVersion: "Test OS 1.0"
    },
    location: {
      latitude: 37.7749,
      longitude: -122.4194,
      accuracy: 10
    }
  };
}

/**
 * Create mock PGP signature (armored format)
 */
function createMockPGPSignature() {
  // This is a mock PGP signature - in real usage this would be generated by OpenPGP
  return `-----BEGIN PGP SIGNATURE-----

iQEzBAABCAAdFiEEMockKeyFingerprintHereABCDEF0123456789QFAmCDEfgAh
CRCMockSignatureDataHereThisIsNotARealPGPSignatureButFollowsTheFormat
MockDataContinuesHereWithBase64EncodedSignatureInformationThatWould
NormallyBeGeneratedByActualPGPLibrariesLikeOpenPGPButThisIsMock
=ABCD
-----END PGP SIGNATURE-----`;
}

/**
 * Create mock device attestation
 */
function createMockAttestation(sessionId) {
  return {
    platform: "android",
    nonce: sessionId,
    timestamp: Date.now(),
    token: "mock_attestation_token_" + crypto.randomUUID()
  };
}

async function testProofModeUpload(videoPath) {
  console.log('ðŸ§ª Testing ProofMode Upload\n');

  // Read video file
  const videoBuffer = readFileSync(videoPath);
  const videoSha256 = await sha256(videoBuffer);

  console.log(`ðŸ“¹ Video: ${videoPath}`);
  console.log(`   Size: ${videoBuffer.length} bytes`);
  console.log(`   SHA-256: ${videoSha256}\n`);

  // Create ProofMode data
  const manifest = createProofModeManifest(videoSha256);
  const manifestJson = JSON.stringify(manifest);
  const manifestBase64 = Buffer.from(manifestJson).toString('base64');

  const signature = createMockPGPSignature();
  const signatureBase64 = Buffer.from(signature).toString('base64'); // Encode PGP signature for HTTP header
  const attestation = createMockAttestation(manifest.sessionId);
  const attestationBase64 = Buffer.from(JSON.stringify(attestation)).toString('base64');

  console.log('ðŸ“‹ Created ProofMode data:');
  console.log(`   Session ID: ${manifest.sessionId}`);
  console.log(`   Timestamp: ${manifest.timestamp}`);
  console.log(`   Frame hashes: ${manifest.frameHashes.length}`);
  console.log(`   Attestation: ${attestation.platform}\n`);

  // Generate keypair and auth
  const { privkey, pubkey } = await generateKeypair();
  const expiration = Math.floor(Date.now() / 1000) + 300;
  const authEvent = await createAuthEvent(pubkey, privkey, videoSha256, expiration);
  const authHeader = 'Nostr ' + Buffer.from(JSON.stringify(authEvent)).toString('base64');

  try {
    console.log('ðŸ“¤ Uploading with ProofMode headers...');
    const response = await fetch(UPLOAD_URL, {
      method: 'PUT',
      headers: {
        'Authorization': authHeader,
        'Content-Type': 'video/mp4',
        'X-ProofMode-Manifest': manifestBase64,
        'X-ProofMode-Signature': signatureBase64,
        'X-ProofMode-Attestation': attestationBase64
      },
      body: videoBuffer
    });

    const result = await response.json();

    if (response.ok) {
      console.log('âœ… Upload successful!');
      console.log(`   URL: ${result.url}`);
      console.log(`   SHA-256: ${result.sha256}`);
      console.log('\nðŸ“Š ProofMode Result:');
      console.log(`   Verified: ${result.proofmode?.verified || false}`);
      console.log(`   Level: ${result.proofmode?.level || 'unknown'}`);
      console.log(`   Device Fingerprint: ${result.proofmode?.deviceFingerprint || 'none'}`);
      console.log(`   Timestamp: ${result.proofmode?.timestamp || 'none'}`);

      if (result.proofmode?.level === 'unverified') {
        console.log('\nâš ï¸  ProofMode validation FAILED');
        console.log('   This is expected with mock signatures');
      } else if (result.proofmode?.verified) {
        console.log('\nâœ… ProofMode validation PASSED!');
      }
    } else {
      console.error('âŒ Upload failed:', response.status, result);
    }
  } catch (error) {
    console.error('âŒ Error:', error.message);
  }
}

const videoPath = process.argv[2] || 'blossom-sdk-worker/example_vine_porn/xvideos.com_336023e33f8838cec10d19da4852e0bf-2.mp4';
testProofModeUpload(videoPath);
